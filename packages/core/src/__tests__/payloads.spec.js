// @flow

import { tcrypto, random } from '@tanker/crypto';
import { expect } from '@tanker/test-utils';

import { signBlock } from '../Blocks/Block';
import {
  serializeTrustchainCreation,
  unserializeTrustchainCreation,
  serializeProvisionalIdentityClaim,
  unserializeProvisionalIdentityClaim,
  serializeBlock,
  unserializeBlock,
} from '../Blocks/payloads';


import { preferredNature, NATURE_KIND } from '../Blocks/Nature';

import makeUint8Array from './makeUint8Array';

import { UpgradeRequiredError } from '../errors.internal';

// NOTE: If you ever have to change something here, change it in the Go code too!
// The test vectors should stay the same
describe('payload test vectors', () => {
  it('correctly deserializes a TrustchainCreation test vector', async () => {
    const trustchainCreation = {
      public_signature_key: new Uint8Array([
        0x66, 0x98, 0x23, 0xe7, 0xc5, 0x0e, 0x13, 0xe0, 0xed, 0x4a, 0x56, 0x91, 0xc6, 0x63, 0xc7, 0xeb,
        0x1b, 0xd6, 0x53, 0x12, 0xd4, 0x8d, 0x21, 0xd4, 0x86, 0x76, 0x0f, 0x04, 0x85, 0x7d, 0xf0, 0xef
      ])
    };

    const payload = trustchainCreation.public_signature_key;

    expect(unserializeTrustchainCreation(payload)).to.deep.equal(trustchainCreation);
  });
  it('correctly deserializes a ProvisionalIdentityClaim test vector', async () => {
    const provisionalIdentityClaim = {
      user_id: makeUint8Array('the user id', tcrypto.HASH_SIZE),
      app_provisional_identity_signature_public_key: makeUint8Array('the app sig pub key', tcrypto.SIGNATURE_PUBLIC_KEY_SIZE),
      tanker_provisional_identity_signature_public_key: makeUint8Array('the tanker sig pub key', tcrypto.SIGNATURE_PUBLIC_KEY_SIZE),
      author_signature_by_app_key: makeUint8Array('the author sig by app key', tcrypto.SIGNATURE_SIZE),
      author_signature_by_tanker_key: makeUint8Array('the author sig by tanker key', tcrypto.SIGNATURE_SIZE),
      recipient_user_public_key: makeUint8Array('user pub key', tcrypto.ENCRYPTION_PUBLIC_KEY_SIZE),
      encrypted_provisional_identity_private_keys: makeUint8Array('both encrypted private keys', tcrypto.ENCRYPTION_PRIVATE_KEY_SIZE * 2
                                                                                      + tcrypto.SEAL_OVERHEAD),
    };

    const payload = new Uint8Array([
      // UserID
      0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x69, 0x64, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // AppProvisionalIdentitySignaturePublicKey
      0x74, 0x68, 0x65, 0x20,
      0x61, 0x70, 0x70, 0x20, 0x73, 0x69, 0x67, 0x20, 0x70, 0x75, 0x62, 0x20,
      0x6b, 0x65, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      // TankerProvisionalIdentitySignaturePublicKey
      0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x6e, 0x6b,
      0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x20, 0x70, 0x75, 0x62, 0x20, 0x6b,
      0x65, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // AuthorSignatureByAppKey
      0x74, 0x68, 0x65, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x20, 0x73,
      0x69, 0x67, 0x20, 0x62, 0x79, 0x20, 0x61, 0x70, 0x70, 0x20, 0x6b, 0x65,
      0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      // AuthorSignatureByTankerKey
      0x74, 0x68, 0x65, 0x20, 0x61, 0x75, 0x74, 0x68,
      0x6f, 0x72, 0x20, 0x73, 0x69, 0x67, 0x20, 0x62, 0x79, 0x20, 0x74, 0x61,
      0x6e, 0x6b, 0x65, 0x72, 0x20, 0x6b, 0x65, 0x79, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // RecipientUserPublicKey
      0x75, 0x73, 0x65, 0x72, 0x20, 0x70, 0x75, 0x62, 0x20, 0x6b, 0x65, 0x79,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // EncryptedProvisionalIdentityPrivateKeys
      0x62, 0x6f, 0x74, 0x68,
      0x20, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x20, 0x70,
      0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x20, 0x6b, 0x65, 0x79, 0x73, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]);

    expect(serializeProvisionalIdentityClaim(provisionalIdentityClaim)).to.deep.equal(payload);
    expect(unserializeProvisionalIdentityClaim(payload)).to.deep.equal(provisionalIdentityClaim);
  });
});

describe('payloads', () => {
  it('should throw when serializing an invalid TrustchainCreation', async () => {
    const trustchainCreation = {
      public_signature_key: new Uint8Array(0),
    };
    expect(() => serializeTrustchainCreation(trustchainCreation)).to.throw();
  });


  it('should serialize/unserialize a TrustchainCreation', async () => {
    const trustchainCreation = {
      public_signature_key: random(tcrypto.SYMMETRIC_KEY_SIZE),
    };

    expect(unserializeTrustchainCreation(serializeTrustchainCreation(trustchainCreation))).to.deep.equal(trustchainCreation);
  });

  it('should throw when unserializing unsupported block version', async () => {
    const block = {
      author: random(tcrypto.HASH_SIZE),
      signature: random(tcrypto.SIGNATURE_SIZE),
      trustchain_id: random(tcrypto.HASH_SIZE),
      payload: new Uint8Array(0),
      index: 0,
      nature: NATURE_KIND.key_publish_to_device,
    };
    const serializedBlock = serializeBlock(block);
    serializedBlock[0] = 99;
    expect(() => unserializeBlock(serializedBlock)).to.throw(UpgradeRequiredError);
  });

  it('should serialize/unserialize a Block', async () => {
    const signatureKeys = tcrypto.makeSignKeyPair();
    const block = {
      trustchain_id: new Uint8Array(tcrypto.HASH_SIZE),
      index: 999,
      nature: preferredNature(NATURE_KIND.key_publish_to_device),
      payload: random(450),
      author: random(tcrypto.HASH_SIZE)
    };
    const signedBlock = signBlock(block, signatureKeys.privateKey);

    expect(unserializeBlock(serializeBlock(signedBlock))).to.deep.equal(signedBlock);
  });
});
